# *** Функции *** 

# Функции можно представить как "фабрику", со входом и выходом

# Функция оперирует данными (объектами)

#  Вариант 1. Функция, которая не имеет входа и выхода

# создание (определение) функции
def func_1():
    print("Hello!")

#вызов функции
# func_1()

def func_2():
    name = "Alexandra"
    print(f"Hello, {name}!") # способ форматирования f-string

# func_2()

# Вариант 2. Функция, которая имеет вход (-ы), но не имеет выхода(-ов)(ничего не возвращает)

# Вход функции - это аргумент

def func_3(argument_1):
    """
    Пример функции с 1-м аргументом под названием argument_1
    """
    result = argument_1 ** 2
    print(result)

# func_3(100) # значение, которое отправляем в функцию называется параметром

def func_4(arg_1, arg_2):
    result = arg_1 + arg_2
    print(result)

# вызов функции с передачей 2-х параметров
# func_4(20, 70) 

# Вариант 2.1. Функция, у которой аргументы имеют значения по умолчанию

def func_5(arg_1, arg_2, arg_3=10):
    result = arg_1 + arg_2 + arg_3
    print(result)

# func_5(10,20) # третьему аргументу передается параметр
# func_5(10,20,5) # третьему аргументу НЕ передается параметр

# *** Позиционные параметры и именованные параметры ***

def custom_sum(a=10, b=20, c=30):
    res = a + b + c
    print(res)

# позиционные параметры
# custom_sum(5, 5) # параметры присваиваются согласно порядку расположения аргументов

# именованные параметры
# custom_sum(c=100) # параметр присваивается конкретному аргументу

# Вариант 2.2. Множественные аргументы

# Множественные позиционные параметры
# можно передавать произвольное количество позиционных параметров
def func_6(*args):
    print(args)

# func_6(100, 200, 300, 400, 500)

def func_7(*args):
    # функция, аккумулирующая (накапливающая) значения параметров в переменной res
    res = 0
    for var in args:
        res += var
    print(res)
# func_7(10, 20, 30, 10)

# множественные именованные параметры
# можем передать произвольное кол-во именованных параметров

def func_8(**kwargs):
    print(kwargs)

# func_8(a=10, b=20, c=30)

# *** Пример. Данные человека ***

def person_data_parser(**args):

    for parameter, value in args.items():
        print(f"{parameter} : {value}")

# person_data_parser(name="Sasha", age=26, prog_lang='Eng')
# person_data_parser(name="Kostya", age=27)


# вариант 3. Функция, которая возвращает значение 

def func_9(x,y):
    z = x + y
    return z

# вызов функции 
result = func_9(10, 20)

# print(result)

# возвращение нескольких значений

def func_10(a,b):
    res_1 = a ** 2
    res_2 = b ** 3
    return res_1, res_2

# print(func_10(2,3))

# присвоение нескольких возвращаемых значений в переменные
val_1, val_2 = func_10(2,3)

# print(val_1, val_2)

# *** Безымянная функция (лямбда-выражения, лямбда-функции) ***

# создание лямбды
# foo = lambda x, y: (x+y)**2
# # вызов лямбда-выражения
# result = foo(2, 3)

# print(result)

# Лямбда внутри списка

# my_lambdas = [lambda arg: arg **2, lambda arg: arg ** 3, lambda arg: arg ** 3]

# print(my_lambdas)

# print(my_lambdas[1](2))

# Лямбда внутри словаря 

lambda_dict = {"вычисление суммы": lambda x, y: x+y, "вычисление произведения": lambda x, y: x*y}

# вызов лямбды из словаря
# print(lambda_dict["вычисление суммы"](2, 4))


# Лямбда внутри генератор списка

# создание списка с использованием лямбды
my_list = [(lambda a: a*2)(n) for n in range(10)]

my_list_2 = [(lambda a, b: (a+b)*(a-b)) for idx, val in enumerate([10,20,30,40,50])]

# создание кастомизированного списка на основе другого списка
origin_list = [3,1,7,4,7,2]
# лямбда с тернарным условным выражением
my_list_3 = [ (lambda x:1 if x > 5 else 0) (n) for n in origin_list]
# print(my_list_3) 

# ***Декоратор ***

# декоратор - один из видов паттернов (шаблонов) программирования (проектирования)
# декоратор - функция, которая добавляет некий доп. функционал целевой функции

# создание декоратора
# def decorator_1(func):
#     '''
#     func : аргумент, которому присваивается объект целевой функции
#     ''' 
#     # обертка
#     def wrapper():
#         # код, который выполняется ДО целевой функции
#         print("foo")

#         # выполнение целевой функции
#         func()

#         # код, который выполняется ПОСЛЕ целевой функции
#         print("bar")

#     # возврат объекта обертки
#     return wrapper

# #целевая функция 
# @decorator_1
# def my_func_1():
#     print("Hello!")

# def my_func_2():
#     print("Привет!")

# my_func_1()
# my_func_2()

def decorator_2(func):
    '''
    func : аргумент, которому присваивается объект целевой функции
    ''' 
    # обертка
    def wrapper(a, b):
        # код, который выполняется ДО целевой функции
        print("foo")
        # выполнение целевой функции с передачей параметров
        func(a, b)
        # код, который выполняется ПОСЛЕ целевой функции
        print("bar")
    # возврат объекта обертки
    return wrapper

@decorator_2
def my_func_3(x,y):
    print(x+y)

my_func_3(10, 5)
